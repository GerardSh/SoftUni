# General
Microsoft се опитват да привлекат програмистите, които традиционно работят директно с бази данни, като ги насочат към работа с колекции в .NET. Самата база данни може да се разглежда като колекция от таблици, всяка таблица – като колекция от редове, а всеки ред – като колекция от колони.

В периода, когато Microsoft популяризират своя език за програмиране, голяма част от бизнес логиката започва да се изнася към приложенията. Това се счита за предимство, тъй като извличането на данни от базата е бавен процес, а разработчиците са съсредоточени предимно върху SQL. Възползвайки се от този факт, Microsoft създават в .NET концепция, която наподобява SQL – езика за заявки LINQ (Language Integrated Query).

Когато по-късно разработват ORM, естествено възниква идеята работата с Entity Framework да бъде интегрирана с LINQ. Това води до широко използване на LINQ при работа с Entity Framework Core, тъй като той осигурява интуитивен начин за обработка на данни в стил, близък до SQL, но с възможност за по-добра интеграция в .NET приложенията.
## Asynchronous Methods
Трябва да използваме асинхронните версии на методите, когато е възможно, защото в противен случай блокираме нишката, която изпълнява заявката. Операциите в базите данни и други бавни операции, като достъп до файловата система или мрежови заявки, обикновено отнемат време за изпълнение. Това е важно, защото ако не използваме асинхронност, нишката ще бъде блокирана, докато чака резултата, което води до неефективно използване на ресурсите.

Независимо от причината за забавянето, ако дадена операция е I/O-bound и изисква време за изпълнение, тя трябва да бъде маркирана като асинхронна. Когато извършваме такива операции асинхронно, позволяваме на сървъра, докато чака резултата, да обработва други заявки. Това води до по-ефективно използване на ресурсите, като позволява на нишките в пула да обслужват повече потребители.

Докато приложението чака резултат от външен източник, какъвто е базата данни, сървърът може да продължи да обработва други заявки. Дори ако на сървъра работи само нашето приложение, асинхронността носи ползи при увеличен брой потребители, тъй като позволява по-добро управление на наличните нишки.

Ако например сървърната машина разполага с осем ядра, това означава, че физически могат да работят само осем нишки едновременно. Ако дадена нишка е блокирана, докато чака отговор от базата данни, тя не може да изпълнява друга задача, което ограничава капацитета на сървъра. Използвайки асинхронни методи, позволяваме на системата да освободи нишката, докато чака резултат, така че тя да бъде използвана за обработка на друга заявка.

Важно е да се отбележи, че шаблонът `async/await` не гарантира, че операцията ще бъде изпълнена асинхронно на ниво хардуер. Това зависи от .NET Runtime, който решава дали операцията ще бъде обработена асинхронно въз основа на натоварването на системата и естеството на самата задача. Въпреки това, използването на асинхронни методи дава възможност на системата динамично да управлява ресурсите и да подобри производителността при работа с бавни операции.

Ако не материализираме заявката, тя няма да бъде изпълнена, докато не се опитаме да я използваме. Например, ако използваме `foreach` върху резултата от заявка, това автоматично ще я материализира и ще я изпълни веднага. Това обаче означава, че губим възможността да изпълним заявката асинхронно, тъй като `foreach` блокира изпълнението, докато не се получат всички резултати. За да запазим асинхронността, трябва да използваме подходящи методи като `ToListAsync()` или `ToArrayAsync()`, които материализират заявката по асинхронен начин. Желателно е да я материализираме асинхронно възможно най-късно, точно преди да ни потрябват данните.
## Filtering
`Where()` - Selects values that are based on a predicate function

```csharp
string[] words = { "the", "quick", "brown", "fox", "jumps" };

// Using the LINQ method Where to filter the words with length 3
IEnumerable<string> query =
       words.Where(word => word.Length == 3); 

// Classical LINQ achiving the same
IEnumerable<string> query = from word in words
							where word.Length == 3
							select word; 
```

Класическият LINQ (query syntax) предлага по-декларативен начин за изразяване на заявки, подобен на SQL. Той използва ключови думи като `from`, `where` и `select`, което прави кода по-четим в определени случаи. Въпреки това, синтаксисът с разширяващи методи (`Where()`, `Select()`, `OrderBy()`) е по-гъвкав и предпочитан в повечето сценарии, особено когато комбинираме множество операции.
## Select
Методът `Select` ни позволява да направим проекция върху данните, което води до намаляване на мрежовия трафик и бързината за тяхното доставяне, благодарение на по-малкия обем върната информация. Друг голям плюс е че нашите ентити модели, не трябва да ходят навън.
Чрез избора на само необходимите колони и поставянето им в анонимен обект, можем ефективно да получим само данните, от които се нуждаем. 

```csharp
var employeesWithTown = context
 .Employees
 .Select(employee => new
 {
 EmployeeName = employee.FirstName,
 TownName = employee.Address.Town.Name
 });
```

**SQL Server Profiler:**

```sql
SELECT [employee].[FirstName] AS [EmployeeName], [employee.Address.Town].[Name] AS [TownName]
 FROM [Employees] AS [employee]
LEFT JOIN [Addresses] AS [employee.Address] ON [employee].[AddressID] = [employee.Address].[AddressID]
LEFT JOIN [Towns] AS [employee.Address.Town] ON [employee.Address].[TownID] =
 [employee.Address.Town].[TownID]
```

Един от недостатъците на анонимните обекти е, че когато ги подадем към метод, те се третират като `object`, което води до загуба на типизация и ограничаване на достъпа до техните пропъртита. Това означава, че извън контекста на създаването на анонимния обект няма лесен директен достъп до пропъртитата му.

Ако използваме анонимен обект или DTO, губим възможността да се възползваме от `change tracker`-а на Entity Framework, тъй като обектът, с който работим, не е ентити и не може да се използва за ъпдейтване на базата данни, той вече не е част от контекста. DTO обектите са задължителни за комуникацията между клиента и приложението, тъй като позволяват да се изпрати само нужната информация, която клиентът иска да промени. Когато потребителят прави промяна, не е препоръчително да изпращаме директно ентити, а да изпратим DTO обект, който съдържа само необходимите данни. След като получим DTO обекта, можем да валидираме данните и след това да актуализираме съответното ентити, което вече сме заредили от базата. Ентититата не трябва да напускат границите на нашето приложение, за да предотвратим нежелани странични ефекти и да гарантираме сигурността на данните.
### DTO
За да избегнем проблема с анонимните обекти, можем да създадем DTO (Data Transfer Object) клас, в който дефинираме необходимите пропъртита за проекцията. Голямото предимство е, че можем да валидираме информацията, която идва от клиента, и да осигурим по-добра сигурност при манипулиране на данните. 
Много е важно, всеки бит информация да бъде проверен и валидиран дали отговаря на поне формални правила, ако примерно получаваме ЕГН, трябва да проверим че съдържа 10 цифри, без нищо друго .

От .NET 8 и C# 11 имаме новата функционалност `required`, която ни позволява да зададем изисквания към дадено пропърти. Когато използваме `required`, определяме, че пропъртито трябва да бъде зададено при създаването на обекта. Това предотвратява създаването на обекти с незадължителни или липсващи критични данни.

Пример с `required`:

```csharp
public class MyDto
{
    public required string Name { get; set; }
}

```

Това означава, че при създаване на обект от класа `MyDto`, пропъртито `Name` трябва да бъде зададено, в противен случай ще получим компилационна грешка. Така се гарантира, че данните, които получаваме от клиента, са валидни и пълни.

DTO обектите имат атрибути, които са предназначени за валидация на клиентските данни, докато базовите модели, използвани за работа с базата данни, имат атрибути, които влияят на самата база. Например, можем да използваме атрибути като `[Required]` и за клиентска валидация, за да гарантираме, че определени полета не са празни при подадени данни.
## Aggregation
Тези функции работят по същия начин, както и в базата данни, с разликата, че някои от тях могат да приемат предикат, което позволява допълнителна филтрация директно в метода.

Например, SQL заявката:

```sql
SELECT COUNT(*) FROM Employees AS e
WHERE e.DepartmentID = 1
```

Може да бъде изразена в LINQ с предикат по следния начин:

```csharp
context.Employees
.Where(e => e.DepartmentId == 1)
.Count();

// Alternatively
context.Employees
.Count(e => e.DepartmentId == 1);
```

И двете ще генерират еднаква заявка, като разликата е че ползвайки предикат, се намалява дължината на кода.

Освен `Count`, LINQ предоставя и други агрегиращи функции като `Average`, `Max`, `Min` и `Sum`, като всички те имат асинхронни версии: `CountAsync`, `AverageAsync`, `MaxAsync`, `MinAsync` и `SumAsync`.
## Joining Tables
### Implicit Join
Най-оптимално е `JOIN` операциите да се извършват по външни ключове, тъй като релационните бази данни поддържат индекси върху тях, което значително подобрява производителността на заявките. Когато използваме `JOIN` по foreign key, няма необходимост от използване на extension метода `Join`, тъй като Entity Framework автоматично генерира съответното присъединяване при достъп до навигационните свойства.

Методът `Join` в LINQ е предназначен за случаи, в които няма дефинирана релация между таблиците, но такива случаи са изключително редки и често индикират проблеми с дизайна на базата данни. Използването му трябва да бъде добре обмислено, тъй като може да доведе до неочаквани резултати и неоптимални заявки.

Например, ако изпълним следната LINQ заявка:

```csharp
var query = context.Employees
    .Where(e => e.DepartmentId == 1)
    .Select(e => new
    {
        e.FirstName,
        e.LastName,
        e.JobTitle,
        Department = e.Department.Name
    })
    .ToList();
```

Генерираната SQL заявка ще бъде:

```sql
SELECT [e].[FirstName], [e].[LastName], [e].[JobTitle], [d].[Name] AS [Department]
FROM [Employees] AS [e]
INNER JOIN [Departments] AS [d] ON [e].[DepartmentID] = [d].[DepartmentID]
WHERE [e].[DepartmentID] = 1
```

EF прави `JOIN` без да сме го посочвали експлицитно, защото използвахме нещо от Department класа. Реално в момента в който EF види, че имаме нужда от информация намираща се в таблицата към която има релация, автоматично генерира `JOIN`.

В този случай EF автоматично създава `JOIN`, въпреки че не сме го дефинирали изрично. Това се случва, защото използваме пропъртито (`Name`) от навигационното пропърти `Department`. В момента, в който EF установи необходимост от достъп до данни от релационна таблица, той генерира съответното присъединяване, за да осигури коректното извличане на информацията.
### Join
Методът `Join` в LINQ позволява ръчно свързване на две колекции, когато между тях няма дефинирана навигационна релация. Той изисква като първи аргумент втората колекция, с която ще извършим `JOIN`, след което посочваме двете пропъртита, които ще бъдат използвани за свързване. В последния аргумент изграждаме резултатния обект, комбинирайки данните от двете таблици.

Пример за използване на `Join`:

```csharp
var employees = context.Employees
    .Join(
        context.Departments,
        e => e.DepartmentId,
        d => d.DepartmentId,
        (e, d) => new
        {
            e.FirstName,
            e.LastName,
            Department = d.Name
        })
    .ToList();
```

В този случай `Employees` и `Departments` се обединяват по `DepartmentId`. Тъй като няма навигационно пропърти, използваме `Join`, за да изпълним `INNER JOIN` ръчно. В повечето случаи, когато в базата данни има дефинирани релации, използването на навигационни пропъртита е по-естественият и препоръчителен подход, тъй като EF автоматично генерира `JOIN` без нужда от явното му деклариране.

В LINQ, методът `Join` обикновено се използва за проекция, т.е. за комбиниране на данни от две или повече колекции в нов обект или анонимен тип. Основната цел на `Join` е да обедини конкретни пропъртита  от свързаните таблици, а не да върне целите ентитети.
### Include
Ако искаме да получим целите ентитети, можем да използваме `Include`, което е специален метод в Entity Framework, предназначен за зареждане на свързани ентитети чрез навигационни пропъртита. Това дава възможност за зареждане на свързаните обекти, без да е нужно да използваме метода `Join` или да достъпваме навигационно пропърти.

Пример:

```csharp
var employeesWithDepartments = context.Employees
    .Include(e => e.Department)
    .ToList();
```

В този пример, чрез `Include`, зареждаме целия `Department` ентитет за всеки служител, който се намира в резултата. EF изпълнява left outer join, което означава, че дори ако даден служител няма свързан департамент, той ще бъде включен в резултата, като стойността за департамент ще бъде `null`. 

Това поведение е аналогично на изпълнение на SQL заявка с `LEFT OUTER JOIN`, при която всички редове от таблицата на служителите ще се върнат, независимо дали съществува съвпадение в таблицата на департаментите. Ако няма съвпадение, полето за департамент ще съдържа `NULL`.

EF може да оптимизира заявката, като използва inner join, но това е само когато свързаните ентитита са гарантирано налични за всички записи в основния ентитет например, всички служители имат департамент. EF автоматично прави тази оптимизация в зависимост от структурата на данните и може да преминава между вътрешен и външен join

Ключовата разлика е, че когато използваме `Include`, се оставяме на Entity Framework да управлява генерирането на SQL заявката и да се справи със свързаните таблици, без ние да пишем явен `JOIN` в заявката.
Include се използва, когато искаме да заредим целия свързан ентитет, запазвайки навигационните пропъртита и цялата структура на обектите. Освен това, получаваме и автоматично управление на промените чрез change tracking, което означава, че Entity Framework ще следи за модификациите на тези обекти и ще може да ги синхронизира с базата данни.
## Grouping Tables in EF
За да групираме данните, в LINQ имаме метода`GroupBy`, но трябва много да се внимава, защото има разлика между това дали изпълняваме метода спрямо базата или колекция в паметта. Примерно ако направим следното групиране:

```csharp
var employees = context.Employees
    .GroupBy(e => e.JobTitle)
    .ToList();
```

Ще хвърли exception, защото няма да може да преведе заявката. Причината е че не сме спазили правилата, които са валидни от страна на SQL, а именно че не сме направили проекция, селектирайки само колоната / колоните, които участват в групирането или колони, които са част от агрегираща функция.

Ако прехвърлим колекцията първо в паметта и изпълним `GroupBy` отново, тогава ще работи без проблеми, защото нямаме ограниченията наложени от SQL, но това означава, че всички записи първо ще бъдат заредени в паметта, което може да бъде проблем при големи обеми данни.

```csharp
var employees = context.Employees
    .ToList();

var groupedEmployees = employees
    .GroupBy(e => e.JobTitle)
    .ToList();


foreach (var grp in groupedEmployees)
{
    Console.WriteLine($"{grp.Key} - {grp.Sum(e=> e.Salary)}");
}
```

Правилният начин да направим групиране директно на ниво база е да използваме `Select` след `GroupBy`, за да формираме коректна SQL заявка, която спазва ограниченията на `GROUP BY`:

```csharp
var groupedEmployees = context.Employees
    .GroupBy(e => e.JobTitle)
    .Select(grp => new
    {
        Department = grp.Key,
        Salary = grp.Sum(e => e.Salary)
    })
    .ToList();

foreach (var grp in groupedEmployees)
{
    Console.WriteLine($"{grp.Department} - {grp.Salary}");
}
```

Може да направим групиране и по повече колони, като тогава трябва да ги подадем като анонимен обект, поради което пропъртито `Key` вече няма да бъде стринг но анонимен обект съдържащ имената на подадените колони:

```csharp
var groupedEmployees = context.Employees
    .GroupBy(e => new
    {
        e.JobTitle,
        Department = e.Department.Name
    })
    .Select(grp => new
    {
        grp.Key.Department,
        grp.Key.JobTitle,
        Sum = grp.Sum(e => e.Salary)
    })
    .ToList();

foreach (var grp in groupedEmployees)
{
    Console.WriteLine($"{grp.JobTitle} - {grp.Department} - {grp.Sum}");
}
```

Като обобщение, `GroupBy` в LINQ работи по същия начин като `GROUP BY` в базата данни. Единствената разлика е, че когато го използваме директно в LINQ към база данни, трябва да спазваме SQL ограниченията—всички колони, които не са част от `GROUP BY`, трябва да бъдат агрегирани.

В паметта (`ToList()` преди `GroupBy`) тези ограничения не важат, защото LINQ използва обектно-ориентирана логика, а не SQL. В този случай `GroupBy` работи като стандартен `.NET` метод, който групира елементи в `IEnumerable<IGrouping<TKey, TElement>>`, без да изисква допълнителна проекция.

Ако изключим ограниченията, поведението е идентично.
## Expression Tree
Expression Tree в .NET предоставя начин за представяне на кода като обектен модел, което позволява анализ и модифициране на заявките преди тяхното изпълнение. Това е особено полезно при работата с LINQ, където заявките могат да бъдат трансформирани динамично, преди да се превърнат в SQL или друга форма за изпълнение.

Entity Framework Core използва Expression Trees, за да обработва и оптимизира заявките, като позволява добавяне на допълнителни условия, промяна на селектираните колони или дори комбиниране на различни изрази. Това осигурява гъвкавост и възможност за динамично изграждане на заявки според нуждите на приложението.
# Misc
## EF Core Explicit Column Selection
При генерирането на заявки, EF никога не използва `SELECT *`, а винаги изрежда конкретните колони. Това се прави именно за да се избегнат грешки при промени в схемата на базата данни. Ако в таблицата бъдат добавени нови колони, но моделът в приложението не е актуализиран, използването на `SELECT *` би довело до получаване на неочаквани данни, които EF Core не знае как да обработи. Изричното изброяване на колоните гарантира, че заявките ще върнат само тези данни, които съответстват на дефинирания модел.
# ChatGPT
# Bookmarks
Completion: 25.02.2025